///
/// MIT License
/// Copyright (c) 2018-2019 Jongmin Yun
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
/// SOFTWARE.
///

#ifdef MATH_ENABLE_RTTR
#include <Math/Common/XRttrEntry.h>

// Include files that need to be reflected.
#include <Math/Type/Math/DVector2.h>
#include <Math/Type/Math/DVector3.h>
#include <Math/Type/Math/DVector4.h>

namespace dy::math
{

//!
//! DVector2 series
//!

__EXPR_REFLECTION_INSTANCE_INITIALIZE(DVector2<TU8>);
__EXPR_REFLECTION_INSTANCE_INITIALIZE(DVector2<TU16>);
__EXPR_REFLECTION_INSTANCE_INITIALIZE(DVector2<TU32>);
__EXPR_REFLECTION_INSTANCE_INITIALIZE(DVector2<TU64>);
__EXPR_REFLECTION_INSTANCE_INITIALIZE(DVector2<TI8>);
__EXPR_REFLECTION_INSTANCE_INITIALIZE(DVector2<TI16>);
__EXPR_REFLECTION_INSTANCE_INITIALIZE(DVector2<TI32>);
__EXPR_REFLECTION_INSTANCE_INITIALIZE(DVector2<TI64>);

//!
//! Detail Functions
//!

namespace detail
{

static void __InitDVector2()
{
  __EXPR_REFLECTION_INSTANCE_START(DVector2<TU8>)
  {
    EXPR_REGISTER_TYPE(DVector2<TU8>)
      .EXPR_REGISTER_VARIABLE(DVector2<TU8>, X)
      .EXPR_REGISTER_VARIABLE(DVector2<TU8>, Y)
  };
  __EXPR_REFLECTION_INSTANCE_START(DVector2<TU16>)
  {
    EXPR_REGISTER_TYPE(DVector2<TU16>)
      .EXPR_REGISTER_VARIABLE(DVector2<TU16>, X)
      .EXPR_REGISTER_VARIABLE(DVector2<TU16>, Y)
  };
  __EXPR_REFLECTION_INSTANCE_START(DVector2<TU32>)
  {
    EXPR_REGISTER_TYPE(DVector2<TU32>)
      .EXPR_REGISTER_VARIABLE(DVector2<TU32>, X)
      .EXPR_REGISTER_VARIABLE(DVector2<TU32>, Y)
  };
  __EXPR_REFLECTION_INSTANCE_START(DVector2<TU64>)
  {
    EXPR_REGISTER_TYPE(DVector2<TU64>)
      .EXPR_REGISTER_VARIABLE(DVector2<TU64>, X)
      .EXPR_REGISTER_VARIABLE(DVector2<TU64>, Y)
  };
  __EXPR_REFLECTION_INSTANCE_START(DVector2<TI8>)
  {
    EXPR_REGISTER_TYPE(DVector2<TI8>)
      .EXPR_REGISTER_VARIABLE(DVector2<TI8>, X)
      .EXPR_REGISTER_VARIABLE(DVector2<TI8>, Y)
  };
  __EXPR_REFLECTION_INSTANCE_START(DVector2<TI16>)
  {
    EXPR_REGISTER_TYPE(DVector2<TI16>)
      .EXPR_REGISTER_VARIABLE(DVector2<TI16>, X)
      .EXPR_REGISTER_VARIABLE(DVector2<TI16>, Y)
  };
  __EXPR_REFLECTION_INSTANCE_START(DVector2<TI32>)
  {
    EXPR_REGISTER_TYPE(DVector2<TI32>)
      .EXPR_REGISTER_VARIABLE(DVector2<TI32>, X)
      .EXPR_REGISTER_VARIABLE(DVector2<TI32>, Y)
  };
  __EXPR_REFLECTION_INSTANCE_START(DVector2<TI64>)
  {
    EXPR_REGISTER_TYPE(DVector2<TI64>)
      .EXPR_REGISTER_VARIABLE(DVector2<TI64>, X)
      .EXPR_REGISTER_VARIABLE(DVector2<TI64>, Y)
  };
};

};

void InitializeMathReflections()
{
  detail::__InitDVector2();
}

} /// ::dy::math namespace
#endif
